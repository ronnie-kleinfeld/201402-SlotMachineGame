package com.gotchaslots.slots.mobile.ui.common.components.freeActionScript.fountain{	import com.gotchaslots.slots.mobile.ui.common.components.SpriteEx;	import com.greensock.TimelineLite;	import com.greensock.TweenMax;	import com.greensock.easing.Linear;	import com.greensock.easing.Sine;		import flash.events.Event;	import flash.geom.Point;
	
	public class MovingFountain extends SpriteEx	{		private var _fountain:Fountain;		private var _rotator:SpriteEx;		private var _initializer:MovingFountainInitializer;		private var _timeline:TimelineLite;		private var _rotationTween:TweenMax;		private var _linearTween:TweenMax;				private var _linearDuration:Number = 4;		private var _maxLinearDisplacement:int = 100;		private var _minAmplitude:int = 50;		private var _maxAmplitude:int = 150;		private var _rotationDurationMin:Number = 12;		private var _rotationDurationMax:Number = 20;		private var _oscillationDurationMin:Number = 2;		private var _oscillationDuratiomMax:Number = 4;		private var _linearMotionDelay:Number = 5;				private var _dx:int;		private var _dy:int;		private var _currentRotation:int = -1;		private var _started:Boolean = false;		private var _popping:Boolean = false;				public function MovingFountain(startPoint:Point, bitmapClass:Class)		{			_fountain = new Fountain(bitmapClass);			_rotator = new SpriteEx;			_initializer = new MovingFountainInitializer(this, startPoint);						_rotator.addChild(_fountain);			addChild(_rotator);						_rotator.rotation = Math.random() * 360;			_fountain.rotation = -_rotator.rotation;						_dx = Math.random() * _maxLinearDisplacement * 2 - _maxLinearDisplacement;			_dy = Math.random() * _maxLinearDisplacement * 2 - _maxLinearDisplacement;		}				public function get started():Boolean		{			return _started;		}				public function get popping():Boolean		{			return _popping;		}				public function get radius():Number		{			return _fountain.radius;		}				public function init(controlPoint:Point, endPoint:Point):void		{			_started = true;			_initializer.start(controlPoint, endPoint);			play();			TweenMax.delayedCall(_linearMotionDelay, startLinearMotion);		}				public function play():void		{			_started = true;						if (null == _timeline) startOscillation();			else _timeline.play();						if (null == _rotationTween) startRotation();			else _rotationTween.play();		}				public function stop():void		{			_timeline.stop();			_rotationTween.pause();			_linearTween.pause();		}				public function pop():void		{			_popping = true;			_fountain.addEventListener(Event.COMPLETE, OnPopComplete);			_fountain.pop();		}				public function getGlobalPosition():Point		{			return _fountain.localToGlobal(new Point(0, 0));		}				public function destroy():void		{			if (null != _timeline)			{				_timeline.kill();				_timeline = null;			}			if (null != _rotationTween)			{				_rotationTween.kill();				_rotationTween = null;			}			if (null != _linearTween)			{				_linearTween.kill();				_linearTween = null;			}						TweenMax.killTweensOf(_rotator);			TweenMax.killTweensOf(_fountain);			TweenMax.killTweensOf(this);			TweenMax.killDelayedCallsTo(startLinearMotion);						_currentRotation = -1;						_fountain.removeEventListener(Event.COMPLETE, OnPopComplete);			_fountain.destroy();						_initializer.destroy();			_initializer = null;		}				private function startLinearMotion():void		{			if (null != _linearTween) _linearTween.kill();						_linearTween = TweenMax.to(this, _linearDuration, {x: x + _dx, y: y + _dy, ease: Linear.easeNone, onComplete: startLinearMotion});		}				private function startOscillation():void		{			if (null != _timeline) _timeline.kill();						_timeline = new TimelineLite({onComplete: OnOscillationComplete});						var amplitude:int = _minAmplitude + Math.random() * (_maxAmplitude - _minAmplitude);			_timeline.append(new TweenMax(_fountain, getRandomOscillationDuration(), {y: amplitude, ease: Sine.easeOut}));			_timeline.append(new TweenMax(_fountain, getRandomOscillationDuration(), {y: 0, ease: Sine.easeIn}));						amplitude = _minAmplitude + Math.random() * (_maxAmplitude - _minAmplitude);			_timeline.append(new TweenMax(_fountain, getRandomOscillationDuration(), {y: -amplitude, ease: Sine.easeOut}));			_timeline.append(new TweenMax(_fountain, getRandomOscillationDuration(), {y: 0, ease: Sine.easeIn}));		}				private function startRotation(randomize:Boolean = false):void		{			if (null != _rotationTween) _rotationTween.kill();						if ( -1 == _currentRotation)			{				_currentRotation = 360;				randomize = true;			}						if (true == randomize)			{				var multiplier:int = 1;				if (.5 < Math.random()) multiplier = -1;								_currentRotation *= multiplier;			}						var duration:Number = _rotationDurationMin + Math.random() * (_rotationDurationMax - _rotationDurationMin);			_rotationTween = TweenMax.to(_rotator, duration, {rotation: _currentRotation, ease: Linear.easeNone, onComplete: startRotation, onUpdate: OnRotationUpdate});		}				private function OnOscillationComplete():void		{			startRotation(true);			startOscillation();		}				private function OnRotationUpdate():void		{			_fountain.rotation = -_rotator.rotation;		}				private function getRandomOscillationDuration():Number		{			return _oscillationDurationMin + Math.random() * (_oscillationDuratiomMax - _oscillationDurationMin);		}				private function OnPopComplete(e:Event):void		{			_fountain.removeEventListener(Event.COMPLETE, OnPopComplete);			dispatchEvent(new Event(Event.COMPLETE));		}	}}